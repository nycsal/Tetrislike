<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=320, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>KaKaTris</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #0d1b3c;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      width: 100vw;
      max-width: 320px;
      margin: 0 auto;
    }
    #scoreboard {
      width: 100%;
      text-align: center;
      font-size: 1.15em;
      margin: 0.1em 0 0.1em 0;
      letter-spacing: 2px;
      font-weight: bold;
      color: #fff;
      background: linear-gradient(90deg, #002b80 0%, #0058d6 100%);
      border-radius: 18px;
      box-shadow: 0 4px 22px #0077ff44;
      padding: 0.12em 0 0.07em 0;
      text-shadow: 0 2px 12px #000, 0 0 8px #00e0ff77;
      position: relative;
      z-index: 2;
      border: 2px solid #00e0ff;
      min-height: 28px;
      max-height: 34px;
      height: 2em;
      box-sizing: border-box;
    }
    #kakabanner {
      font-size: 1.7em;
      font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
      font-weight: 900;
      color: #fff;
      letter-spacing: 4px;
      text-shadow:
        0 2px 16px #00e0ff,
        0 0 8px #0077ff,
        2px 2px 0 #222,
        0 0 2px #fff;
      margin-bottom: 0.05em;
      background: linear-gradient(90deg, #00e0ff 10%, #0077ff 90%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      border-radius: 8px;
      border: 2px solid #00e0ff;
      padding: 0.02em 0.2em;
      filter: drop-shadow(0 0 4px #00e0ffcc);
      line-height: 1.1;
      display: inline-block;
    }
    #scoreboard span {
      font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
      font-size: 1em;
      color: #fff;
      margin: 0 0.1em;
      text-shadow: 0 1px 6px #0077ff99;
    }
    #gamebox {
      position: relative;
      width: 280px;
      height: 560px;
      margin: 0 auto;
      display: flex;
      justify-content: center;
      align-items: center;
      background: none;
      touch-action: none;
    }
    #game {
      background: #101b3c;
      border: 4px solid #00e0ff;
      border-radius: 16px;
      box-shadow: 0 0 24px #0077ffaa;
      width: 280px;
      height: 560px;
      position: relative;
      z-index: 1;
      touch-action: none;
    }
    canvas {
      display: block;
      background: #101b3c;
      border-radius: 12px;
      width: 280px !important;
      height: 560px !important;
      touch-action: none;
    }
    #howtoplay {
      position: fixed;
      left: 0; top: 0; width: 100vw; height: 100vh;
      background: rgba(20,16,32,0.92);
      z-index: 99;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: #fff;
      font-size: 1.3em;
      text-align: center;
      animation: fadeIn 0.7s;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    #howtoplay .icon {
      font-size: 2.4em;
      margin: 0.3em;
      color: #ffde59;
      text-shadow: 0 0 8px #0077ff;
    }
    #howtoplay .hint {
      margin: 0.6em 0 0.2em 0;
      font-size: 1.1em;
      color: #ffde59;
    }
    #levelmsg {
      position: absolute;
      left: 0; top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,32,0.88);
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 1.5em;
      font-weight: bold;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
      flex-direction: column;
    }
    #levelmsg.show {
      opacity: 1;
      pointer-events: auto;
    }
    #continueBtn {
      margin-top: 1.2em;
      font-size: 1.1em;
      background: linear-gradient(90deg, #00e0ff 10%, #0077ff 90%);
      color: #fff;
      border: none;
      border-radius: 12px;
      padding: 0.5em 2.5em;
      font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
      font-weight: bold;
      letter-spacing: 2px;
      box-shadow: 0 2px 16px #0077ff88;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s;
    }
    #continueBtn:active {
      background: linear-gradient(90deg, #0077ff 10%, #00e0ff 90%);
      box-shadow: 0 2px 24px #00e0ffcc;
    }
    #gameover {
      position: absolute;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background: rgba(10,10,30,0.93);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
      color: #fff;
      font-size: 2em;
      font-weight: bold;
      letter-spacing: 2px;
      text-shadow: 0 0 16px #0077ff, 0 0 8px #00e0ff;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
    }
    #gameover.show {
      opacity: 1;
      pointer-events: auto;
    }
    #restartBtn {
      margin-top: 1.2em;
      font-size: 1.1em;
      background: linear-gradient(90deg, #00e0ff 10%, #0077ff 90%);
      color: #fff;
      border: none;
      border-radius: 12px;
      padding: 0.5em 2.5em;
      font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
      font-weight: bold;
      letter-spacing: 2px;
      box-shadow: 0 2px 16px #0077ff88;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s;
    }
    #restartBtn:active {
      background: linear-gradient(90deg, #0077ff 10%, #00e0ff 90%);
      box-shadow: 0 2px 24px #00e0ffcc;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
    #controls {
      margin-top: 0.7em;
      color: #aaa;
      font-size: 1em;
      text-align: center;
      user-select: none;
    }
    @media (max-width: 400px) {
      #gamebox, #game {
        width: 280px;
        height: 560px;
        max-width: 280px;
        max-height: 560px;
        min-width: 280px;
        min-height: 560px;
      }
    }
  </style>
</head>
<body>
  <div id="scoreboard">
    <div id="kakabanner">KaKaTris</div>
    <span id="score">Score: 0</span> &nbsp;|&nbsp;
    <span id="lines">Lines: 0</span> &nbsp;|&nbsp;
    <span id="level">Level: 1</span>
  </div>
  <div id="gamebox">
    <div id="game">
      <canvas id="tetris" width="280" height="560"></canvas>
      <div id="levelmsg"></div>
      <div id="gameover">
        <div>GAME OVER</div>
        <button id="restartBtn">RESTART</button>
      </div>
    </div>
  </div>
  <div id="controls">
    <p>
      <b>Drag left/right:</b> Move block<br>
      <b>Swipe down:</b> Drop<br>
      <b>Tap:</b> Rotate
    </p>
  </div>
  <div id="howtoplay">
    <div class="hint">How to Play</div>
    <div>
      <span class="icon">&#8592;</span>
      <span>Drag left/right: <b>Move block</b></span>
    </div>
    <div>
      <span class="icon">&#8594;</span>
      <span>Drag left/right: <b>Move block</b></span>
    </div>
    <div>
      <span class="icon">&#8595;</span>
      <span>Swipe down: <b>Drop</b></span>
    </div>
    <div>
      <span class="icon">&#8635;</span>
      <span>Tap: <b>Rotate</b></span>
    </div>
    <div style="margin-top:1.2em;font-size:1em;color:#fff;opacity:0.8;">
      Tap anywhere to start
    </div>
  </div>
  <script>
    // --- Tetris Constants ---
    const COLS = 10, ROWS = 20, BLOCK = 28;
    const COLORS = [
      null,
      "#00ffff", // I
      "#0000ff", // J
      "#ff7f00", // L
      "#ffff00", // O
      "#00ff00", // S
      "#800080", // T
      "#ff0000"  // Z
    ];
    const SHAPES = [
      [],
      [[0,1],[1,1],[2,1],[3,1]], // I
      [[0,0],[0,1],[1,1],[2,1]], // J
      [[2,0],[0,1],[1,1],[2,1]], // L
      [[1,0],[2,0],[1,1],[2,1]], // O
      [[1,0],[2,0],[0,1],[1,1]], // S
      [[1,0],[0,1],[1,1],[2,1]], // T
      [[0,0],[1,0],[1,1],[2,1]]  // Z
    ];
    const levelLines = [3,4,5,6,7,8,9,999];

    // --- Game State ---
    let arena, score, lines, level, dropInterval, dropCounter, lastTime, gameOver;
    let piece, nextPiece;
    let touchStart = null, touchMoved = false, lastTouchX = 0, dragMode = false;
    let gameStarted = false;
    let linesAtLevelStart = 0;
    let levelPaused = false;
    let animationFrameId = null;

    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const levelMsg = document.getElementById('levelmsg');
    const gameoverDiv = document.getElementById('gameover');
    const restartBtn = document.getElementById('restartBtn');

    // --- Add Continue Button for Level Up ---
    function showContinueBtn() {
      if (!document.getElementById('continueBtn')) {
        const btn = document.createElement('button');
        btn.id = 'continueBtn';
        btn.textContent = 'CONTINUE';
        btn.onclick = () => {
          levelPaused = false;
          levelMsg.classList.remove('show');
          hideContinueBtn();
          ensureGameLoop();
        };
        levelMsg.appendChild(btn);
      }
    }
    function hideContinueBtn() {
      const btn = document.getElementById('continueBtn');
      if (btn) btn.remove();
    }

    function resetGameState() {
      arena = createMatrix(COLS, ROWS);
      score = 0;
      lines = 0;
      level = 1;
      dropInterval = 800;
      dropCounter = 0;
      lastTime = performance.now();
      gameOver = false;
      piece = null;
      nextPiece = null;
      linesAtLevelStart = 0;
      lastTouchX = 0;
      dragMode = false;
      gameoverDiv.classList.remove('show');
      levelPaused = false;
      hideContinueBtn();
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }

    function announceLevel() {
      const linesNeeded = levelLines[level-1] || 3;
      levelMsg.innerHTML = `Clear <span style="color:#ffde59">${linesNeeded}</span> line${linesNeeded>1?'s':''} to reach Level ${level+1}!`;
      showContinueBtn();
      levelPaused = true;
      levelMsg.classList.add('show');
    }

    function createMatrix(w, h) {
      const matrix = [];
      while (h--) matrix.push(new Array(w).fill(0));
      return matrix;
    }

    // Draw checkerboard background grid
    function drawBackgroundGrid() {
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          ctx.save();
          ctx.globalAlpha = ((x + y) % 2 === 0) ? 0.09 : 0.18;
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
          ctx.restore();
        }
      }
    }

    // Modern block rendering: rounded, vibrant, soft highlight
    function drawBlock(x, y, color) {
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x * BLOCK + 6, y * BLOCK);
      ctx.lineTo((x + 1) * BLOCK - 6, y * BLOCK);
      ctx.quadraticCurveTo((x + 1) * BLOCK, y * BLOCK, (x + 1) * BLOCK, y * BLOCK + 6);
      ctx.lineTo((x + 1) * BLOCK, (y + 1) * BLOCK - 6);
      ctx.quadraticCurveTo((x + 1) * BLOCK, (y + 1) * BLOCK, (x + 1) * BLOCK - 6, (y + 1) * BLOCK);
      ctx.lineTo(x * BLOCK + 6, (y + 1) * BLOCK);
      ctx.quadraticCurveTo(x * BLOCK, (y + 1) * BLOCK, x * BLOCK, (y + 1) * BLOCK - 6);
      ctx.lineTo(x * BLOCK, y * BLOCK + 6);
      ctx.quadraticCurveTo(x * BLOCK, y * BLOCK, x * BLOCK + 6, y * BLOCK);
      ctx.closePath();
      const grad = ctx.createLinearGradient(
        x * BLOCK, y * BLOCK, (x + 1) * BLOCK, (y + 1) * BLOCK
      );
      grad.addColorStop(0, "#fff");
      grad.addColorStop(0.18, color);
      grad.addColorStop(1, "#222");
      ctx.fillStyle = grad;
      ctx.shadowColor = color + "88";
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(x * BLOCK + BLOCK / 2, y * BLOCK + BLOCK / 2, BLOCK / 2.6, Math.PI * 1.2, Math.PI * 1.9);
      ctx.fill();
      ctx.restore();
    }

    function drawMatrix(matrix, offset, ghost=false) {
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            ctx.save();
            if (ghost) {
              ctx.globalAlpha = 0.13;
              ctx.strokeStyle = COLORS[value];
              ctx.lineWidth = 4;
              ctx.setLineDash([5, 4]);
              ctx.strokeRect((x+offset.x)*BLOCK+2, (y+offset.y)*BLOCK+2, BLOCK-4, BLOCK-4);
              ctx.setLineDash([]);
            } else {
              ctx.globalAlpha = 1;
              drawBlock(x + offset.x, y + offset.y, COLORS[value]);
            }
            ctx.restore();
          }
        });
      });
    }

    function drawGhostPiece() {
      if (!piece) return;
      let ghostY = piece.pos.y;
      while (!collide(arena, {matrix: piece.matrix, pos: {x: piece.pos.x, y: ghostY+1}})) {
        ghostY++;
        if (ghostY > ROWS) break;
      }
      drawMatrix(piece.matrix, {x: piece.pos.x, y: ghostY}, true);
    }

    function merge(arena, piece) {
      if (!arena || !piece || !piece.matrix) return;
      piece.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value && arena[y + piece.pos.y] && arena[y + piece.pos.y][x + piece.pos.x] !== undefined) {
            arena[y + piece.pos.y][x + piece.pos.x] = value;
          }
        });
      });
    }

    function collide(arena, piece) {
      if (!arena || !piece || !piece.matrix) return true;
      const [m, o] = [piece.matrix, piece.pos];
      for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
          if (m[y][x] && (
            !arena[y + o.y] ||
            arena[y + o.y][x + o.x] !== 0 ||
            (x + o.x) < 0 ||
            (x + o.x) >= COLS ||
            (y + o.y) >= ROWS
          )) {
            return true;
          }
        }
      }
      return false;
    }

    function rotate(matrix, dir) {
      for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
          [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
      }
      if (dir > 0) matrix.forEach(row => row.reverse());
      else matrix.reverse();
    }

    function createPiece(type) {
      let shape = SHAPES[type];
      const matrix = createMatrix(4, 4);
      shape.forEach(([x, y]) => matrix[y][x] = type);
      return matrix;
    }

    function resetPiece() {
      const types = 'IJLOSTZ';
      if (!nextPiece) nextPiece = types[Math.floor(Math.random()*7)];
      piece = {
        matrix: createPiece(types.indexOf(nextPiece)),
        pos: {x: 3, y: 0}
      };
      nextPiece = types[Math.floor(Math.random()*7)];
      if (collide(arena, piece)) {
        gameOver = true;
        showGameOver();
        stopGameLoop();
        return;
      }
      dropCounter = 0;
      lastTime = performance.now();
      ensureGameLoop();
    }

    function playerDrop() {
      if (gameOver || levelPaused) return;
      piece.pos.y++;
      if (collide(arena, piece)) {
        piece.pos.y--;
        merge(arena, piece);
        let cleared = arenaSweep();
        if (cleared) {
          lines += cleared;
          score += cleared * 100 * level;
          const linesNeeded = levelLines[level-1] || 3;
          if ((lines - linesAtLevelStart) >= linesNeeded) {
            level++;
            linesAtLevelStart = lines;
            dropInterval = Math.max(150, 800 - (level-1)*100);
            announceLevel();
            stopGameLoop();
            updateScore();
            return; // Pause for continue
          }
        }
        updateScore();
        resetPiece();
        return;
      }
      dropCounter = 0;
      ensureGameLoop();
    }

    function playerMove(dir) {
      if (gameOver || levelPaused) return;
      piece.pos.x += dir;
      if (collide(arena, piece)) piece.pos.x -= dir;
      ensureGameLoop();
    }

    function playerRotate() {
      if (gameOver || levelPaused) return;
      const pos = piece.pos.x;
      let offset = 1;
      rotate(piece.matrix, 1);
      while (collide(arena, piece)) {
        piece.pos.x += offset;
        offset = -(offset + (offset>0?1:-1));
        if (offset > piece.matrix[0].length) {
          rotate(piece.matrix, -1);
          piece.pos.x = pos;
          return;
        }
      }
      ensureGameLoop();
    }

    function hardDrop() {
      if (gameOver || levelPaused) return;
      while (!collide(arena, piece)) {
        piece.pos.y++;
        if (piece.pos.y > ROWS) break;
      }
      piece.pos.y--;
      merge(arena, piece);
      let cleared = arenaSweep();
      if (cleared) {
        lines += cleared;
        score += cleared * 100 * level;
        const linesNeeded = levelLines[level-1] || 3;
        if ((lines - linesAtLevelStart) >= linesNeeded) {
          level++;
          linesAtLevelStart = lines;
          dropInterval = Math.max(150, 800 - (level-1)*100);
          announceLevel();
          stopGameLoop();
          updateScore();
          return; // Pause for continue
        }
      }
      updateScore();
      resetPiece();
      ensureGameLoop();
    }

    function arenaSweep() {
      let rowCount = 0;
      let y = arena.length - 1;
      while (y >= 0) {
        if (arena[y].every(cell => cell !== 0)) {
          arena.splice(y, 1);
          arena.unshift(new Array(COLS).fill(0));
          rowCount++;
        } else {
          y--;
        }
      }
      return rowCount;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackgroundGrid();
      drawMatrix(arena, {x:0, y:0});
      if (!gameOver && piece) {
        drawGhostPiece();
        drawMatrix(piece.matrix, piece.pos);
      }
    }

    function updateScore() {
      document.getElementById('score').textContent = 'Score: ' + score;
      document.getElementById('lines').textContent = 'Lines: ' + lines;
      document.getElementById('level').textContent = 'Level: ' + level;
    }

    function update(time = 0) {
      if (!gameStarted) return;
      if (gameOver || levelPaused) {
        draw();
        return;
      }
      const delta = time - lastTime;
      lastTime = time;

      dropCounter += delta;
      if (dropCounter > dropInterval) {
        playerDrop();
      }
      draw();
      animationFrameId = requestAnimationFrame(update);
    }

    function stopGameLoop() {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }
    function ensureGameLoop() {
      if (!animationFrameId && !gameOver && !levelPaused) {
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(update);
      }
    }

    // --- Touch Controls: Drag left/right, swipe down to drop, tap to rotate ---
    canvas.addEventListener('touchstart', function(e) {
      e.preventDefault();
      if (!gameStarted || gameOver || levelPaused) return;
      if (e.touches.length > 1) return;
      touchStart = e.touches[0];
      touchMoved = false;
      dragMode = false;
      lastTouchX = touchStart.clientX;
    }, { passive: false });

    canvas.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (!gameStarted || gameOver || levelPaused) return;
      if (!touchStart) return;
      const touch = e.touches[0];
      const dx = touch.clientX - lastTouchX;
      const totalDx = touch.clientX - touchStart.clientX;
      const totalDy = touch.clientY - touchStart.clientY;
      const minMove = 8;
      if (Math.abs(totalDx) > Math.abs(totalDy)) {
        if (Math.abs(dx) > minMove) {
          const dir = dx > 0 ? 1 : -1;
          playerMove(dir);
          lastTouchX = touch.clientX;
          dragMode = true;
        }
      }
      touchMoved = true;
    }, { passive: false });

    canvas.addEventListener('touchend', function(e) {
      e.preventDefault();
      if (!gameStarted || gameOver || levelPaused) return;
      if (!touchStart) return;
      const touchEnd = e.changedTouches[0];
      const totalDx = touchEnd.clientX - touchStart.clientX;
      const totalDy = touchEnd.clientY - touchStart.clientY;
      const absDx = Math.abs(totalDx), absDy = Math.abs(totalDy);
      const minSwipe = 40;
      if (!dragMode && absDy > minSwipe && totalDy > 0 && absDy > absDx) {
        hardDrop();
      } else if (!touchMoved || (absDx < 10 && absDy < 10)) {
        playerRotate();
      }
      touchStart = null;
      lastTouchX = 0;
      dragMode = false;
      ensureGameLoop();
    }, { passive: false });

    document.addEventListener('keydown', function(e) {
      if (!gameStarted || gameOver || levelPaused) return;
      if (e.key === 'ArrowLeft') { playerMove(-1); ensureGameLoop(); }
      else if (e.key === 'ArrowRight') { playerMove(1); ensureGameLoop(); }
      else if (e.key === 'ArrowUp') { playerRotate(); ensureGameLoop(); }
      else if (e.key === 'ArrowDown') { hardDrop(); ensureGameLoop(); }
    });

    function showGameOver() {
      gameoverDiv.classList.add('show');
    }
    restartBtn.addEventListener('click', function() {
      gameoverDiv.classList.remove('show');
      startGame();
    });

    function hideHowToPlay() {
      let htp = document.getElementById('howtoplay');
      htp.style.animation = 'fadeOut 0.5s';
      setTimeout(function() {
        htp.style.display = 'none';
        startGame();
      }, 450);
    }

    window.addEventListener('DOMContentLoaded', function() {
      var htp = document.getElementById('howtoplay');
      htp.addEventListener('touchstart', hideHowToPlay, { passive: false });
      htp.addEventListener('click', hideHowToPlay, { passive: false });
    });

    function startGame() {
      resetGameState();
      gameStarted = true;
      resetPiece();
      updateScore();
      announceLevel();
      lastTime = performance.now();
      ensureGameLoop();
    }

    // --- Start paused, show how to play ---
    resetGameState();
    draw();
  </script>
</body>
</html>
