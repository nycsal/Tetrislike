<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=320, initial-scale=1.0, user-scalable=no">
    <title>Special Agent Ish</title>
    <style>
        /* ... [Keep all your CSS, but REMOVE the .controls and .control-btn blocks] ... */
        /* Remove .controls and .control-btn styles */
        .controls, .control-btn { display: none !important; }
        /* Add/modify header branding: */
        .game-header {
            color: #fff;
            text-align: center;
            padding: 18px 10px 10px 10px;
            background: rgba(0,0,0,0.3);
            font-family: 'Arial Black', Arial, sans-serif;
            font-size: 1.5em;
            letter-spacing: 2px;
            text-shadow: 2px 2px 8px #000;
        }
        .game-header .score {
            font-size: 22px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .game-header .brand {
            font-size: 1.2em;
            font-weight: bold;
            color: #ffd93d;
            letter-spacing: 1.5px;
            margin-bottom: 3px;
            display: block;
            text-shadow: 0 2px 8px #764ba2;
        }
        /* ... keep the rest of your CSS ... */
    </style>
</head>
<body>
    <div class="game-header">
        <span class="brand">Special Agent Ish</span>
        <div class="score">Score: <span id="score">0</span></div>
        <div class="level">Level: <span id="level">1</span> | Lines: <span id="lines">0</span></div>
    </div>

    <div class="game-container">
        <div class="game-board" id="gameBoard">
            <div class="next-piece">
                <div class="next-label">NEXT</div>
                <div id="nextPiece"></div>
            </div>
        </div>
        <div class="game-over" id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button class="restart-btn" onclick="startNewGame()">Play Again</button>
        </div>
    </div>

    <script>
    // --- TetrisGame class (upgraded for tap controls) ---
    class TetrisGame {
        constructor() {
            this.board = Array(20).fill().map(() => Array(10).fill(0));
            this.currentPiece = null;
            this.nextPiece = null;
            this.score = 0;
            this.level = 1;
            this.lines = 0;
            this.gameRunning = false;
            this.isPaused = false;
            this.fallSpeed = 1000;
            this.gameBoard = document.getElementById('gameBoard');
            this.colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'cyan'];
            this.pieces = [
                [[1,1,1,1]], // I
                [[1,1],[1,1]], // O
                [[0,1,0],[1,1,1]], // T
                [[0,1,1],[1,1,0]], // S
                [[1,1,0],[0,1,1]], // Z
                [[1,0,0],[1,1,1]], // J
                [[0,0,1],[1,1,1]]  // L
            ];
            this.setupTapControls();
            this.generateNextPiece();
            this.spawnPiece();
            this.startGameLoop();
        }

        setupTapControls() {
            // Remove controls panel if present
            let controls = document.querySelector('.controls');
            if (controls) controls.style.display = 'none';

            // Tap on game board
            this.gameBoard.addEventListener('touchstart', (e) => this.handleTap(e));
            this.gameBoard.addEventListener('mousedown', (e) => this.handleTap(e));
        }

        handleTap(e) {
            if (!this.gameRunning || this.isPaused || !this.currentPiece) return;
            let rect = this.gameBoard.getBoundingClientRect();
            let x, y;
            if (e.touches && e.touches.length) {
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            let boardW = this.gameBoard.offsetWidth;
            let boardH = this.gameBoard.offsetHeight;

            // Board is 10x20, each cell 30px (or scaled)
            let col = Math.floor(x / (boardW / 10));
            let row = Math.floor(y / (boardH / 20));

            // Tap bottom 1.5 rows: hard drop at tapped column
            if (row >= 18.5) {
                this.hardDropAt(col);
                return;
            }

            // Tap top 1/3: rotate
            if (row < 6.5) {
                this.rotatePiece();
                return;
            }

            // Tap left third: move left
            if (x < boardW / 3) {
                this.movePiece(-1, 0);
                return;
            }
            // Tap right third: move right
            if (x > boardW * 2 / 3) {
                this.movePiece(1, 0);
                return;
            }
            // Tap center: rotate
            this.rotatePiece();
        }

        hardDropAt(col) {
            // Move piece horizontally to tapped column (if possible)
            let shapeW = this.currentPiece.shape[0].length;
            let targetX = Math.max(0, Math.min(col, 10 - shapeW));
            this.clearPiece();
            this.currentPiece.x = targetX;
            this.renderPiece();
            // Drop down as far as possible
            while (this.movePiece(0, 1)) {
                this.score += 2;
            }
            this.lockPiece();
        }

        generateNextPiece() {
            const pieceType = Math.floor(Math.random() * this.pieces.length);
            const color = this.colors[Math.floor(Math.random() * this.colors.length)];
            this.nextPiece = {
                shape: this.pieces[pieceType].map(row => row.slice()),
                color: color,
                x: 0,
                y: 0
            };
            this.displayNextPiece();
        }

        displayNextPiece() {
            const nextContainer = document.getElementById('nextPiece');
            nextContainer.innerHTML = '';
            const shape = this.nextPiece.shape;
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const block = document.createElement('div');
                        block.className = `block ${this.nextPiece.color}`;
                        block.style.left = (col * 20 + 10) + 'px';
                        block.style.top = (row * 20 + 30) + 'px';
                        block.style.width = '18px';
                        block.style.height = '18px';
                        nextContainer.appendChild(block);
                    }
                }
            }
        }

        spawnPiece() {
            this.currentPiece = {
                shape: this.nextPiece.shape.map(row => row.slice()),
                color: this.nextPiece.color,
                x: Math.floor((10 - this.nextPiece.shape[0].length) / 2),
                y: 0
            };
            if (!this.isValidPosition(this.currentPiece)) {
                this.gameOver();
                return;
            }
            this.generateNextPiece();
            this.renderPiece();
        }

        isValidPosition(piece, offsetX = 0, offsetY = 0) {
            const newX = piece.x + offsetX;
            const newY = piece.y + offsetY;
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const boardX = newX + col;
                        const boardY = newY + row;
                        if (boardX < 0 || boardX >= 10 || boardY >= 20) return false;
                        if (boardY >= 0 && this.board[boardY][boardX]) return false;
                    }
                }
            }
            return true;
        }

        movePiece(dx, dy) {
            if (!this.gameRunning || this.isPaused || !this.currentPiece) return false;
            if (this.isValidPosition(this.currentPiece, dx, dy)) {
                this.clearPiece();
                this.currentPiece.x += dx;
                this.currentPiece.y += dy;
                this.renderPiece();
                return true;
            }
            return false;
        }

        rotatePiece() {
            if (!this.gameRunning || this.isPaused || !this.currentPiece) return;
            const oldShape = this.currentPiece.shape;
            const rotated = oldShape[0].map((_, index) =>
                oldShape.map(row => row[index]).reverse()
            );
            this.clearPiece();
            this.currentPiece.shape = rotated;
            if (this.isValidPosition(this.currentPiece)) {
                this.renderPiece();
            } else {
                this.currentPiece.shape = oldShape;
                this.renderPiece();
            }
        }

        hardDrop() {
            if (!this.gameRunning || this.isPaused || !this.currentPiece) return;
            while (this.movePiece(0, 1)) {
                this.score += 2;
            }
            this.lockPiece();
        }

        clearPiece() {
            const existingBlocks = this.gameBoard.querySelectorAll('.block:not(.locked)');
            existingBlocks.forEach(block => block.remove());
        }

        renderPiece() {
            if (!this.currentPiece) return;
            for (let row = 0; row < this.currentPiece.shape.length; row++) {
                for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                    if (this.currentPiece.shape[row][col]) {
                        const block = document.createElement('div');
                        block.className = `block ${this.currentPiece.color} falling-animation`;
                        block.style.left = ((this.currentPiece.x + col) * 30) + 'px';
                        block.style.top = ((this.currentPiece.y + row) * 30) + 'px';
                        this.gameBoard.appendChild(block);
                    }
                }
            }
        }

        lockPiece() {
            for (let row = 0; row < this.currentPiece.shape.length; row++) {
                for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                    if (this.currentPiece.shape[row][col]) {
                        const boardY = this.currentPiece.y + row;
                        const boardX = this.currentPiece.x + col;
                        if (boardY >= 0) {
                            this.board[boardY][boardX] = this.currentPiece.color;
                        }
                    }
                }
            }
            const lockedBlocks = this.gameBoard.querySelectorAll('.block:not(.locked)');
            lockedBlocks.forEach(block => {
                block.classList.add('locked');
            });
            this.checkLines();
            this.spawnPiece();
        }

        checkLines() {
            const fullLines = [];
            for (let row = 0; row < 20; row++) {
                if (this.board[row].every(cell => cell !== 0)) {
                    fullLines.push(row);
                }
            }
            if (fullLines.length > 0) {
                this.clearLines(fullLines);
            }
        }

        clearLines(fullLines) {
            // Visual effect
            fullLines.forEach(row => {
                const effect = document.createElement('div');
                effect.className = 'line-clear-effect';
                effect.style.top = (row * 30) + 'px';
                this.gameBoard.appendChild(effect);
                setTimeout(() => effect.remove(), 500);
            });
            setTimeout(() => {
                // Remove blocks from cleared lines
                const blocks = this.gameBoard.querySelectorAll('.block.locked');
                blocks.forEach(block => {
                    const blockRow = Math.floor(parseInt(block.style.top) / 30);
                    if (fullLines.includes(blockRow)) {
                        block.remove();
                    }
                });
                // Update board array
                fullLines.forEach(row => {
                    this.board.splice(row, 1);
                    this.board.unshift(Array(10).fill(0));
                });
                // Move remaining blocks down
                this.repositionBlocks();
                // Update score
                const lineScore = [0, 100, 300, 500, 800][fullLines.length];
                this.score += lineScore * this.level;
                this.lines += fullLines.length;
                if (this.lines >= this.level * 10) {
                    this.level++;
                    this.fallSpeed = Math.max(100, 1000 - (this.level-1)*80);
                    clearInterval(this.gameInterval);
                    this.startGameLoop();
                }
                this.updateDisplay();
            }, 250);
        }

        repositionBlocks() {
            const blocks = this.gameBoard.querySelectorAll('.block.locked');
            blocks.forEach(block => {
                const oldRow = Math.floor(parseInt(block.style.top) / 30);
                const col = Math.floor(parseInt(block.style.left) / 30);
                // Find new row position
                let newRow = oldRow;
                for (let row = 19; row >= 0; row--) {
                    if (this.board[row][col] !== 0) {
                        newRow = row;
                        break;
                    }
                }
                block.style.top = (newRow * 30) + 'px';
            });
        }

        gameLoop() {
            if (!this.gameRunning || this.isPaused) return;
            if (!this.movePiece(0, 1)) {
                this.lockPiece();
            }
        }

        startGameLoop() {
            this.gameRunning = true;
            if (this.gameInterval) clearInterval(this.gameInterval);
            this.gameInterval = setInterval(() => this.gameLoop(), this.fallSpeed);
        }

        gameOver() {
            this.gameRunning = false;
            clearInterval(this.gameInterval);
            document.getElementById('finalScore').textContent = this.score;
            document.getElementById('gameOver').style.display = 'block';
        }

        updateDisplay() {
            document.getElementById('score').textContent = this.score;
            document.getElementById('level').textContent = this.level;
            document.getElementById('lines').textContent = this.lines;
        }
    }

    let game = new TetrisGame();

    function startNewGame() {
        document.getElementById('gameOver').style.display = 'none';
        document.getElementById('gameBoard').innerHTML = '<div class="next-piece"><div class="next-label">NEXT</div><div id="nextPiece"></div></div>';
        game = new TetrisGame();
    }

    // Prevent scrolling on mobile
    document.addEventListener('touchmove', function(e) {
        e.preventDefault();
    }, { passive: false });
    </script>
</body>
</html>
